# 调试日志

facade.serverType: 以类名称字符串为索引，存储了所有的core类。凡是子目录下有core.js文件的都视为独立词条，加入该列表
facade.serverTypeMapping: 为避免名称冲突，在原有"IOS"等类型名称前加上类前缀，形成类似"CoreOfChickIOS"的完全名

规定 domain 作为核心类标识(如 CoreOfLogic)，而 uuid 作为唯一登录标识(authwx.13588888888)

逻辑服通讯监控点位
```js
//第一点位
gamecloud/CoreOfBase.onSocketReq;
//第二点位
vallnetverver/CoreOfLogic/middleware/auth.handle
```

CoreOfLogic 的业务耦合性处理的不够好。目前关于随机物品(id==0)先使用 HeroList.json 配置表统一过渡，相关函数:
```js
CoreOfLogic.constructor() {
    this.RegisterResHandle('$default', async (user, bonus) => {
        //不属于特殊物品的普通物品
        if(bonus.type == ResType.PetChipHead && bonus.id == 0){//特殊逻辑：生成随机碎片 2017.7.13
            let rate = Math.random() /*随机数*/, cur = 0/*记录累计概率*/;
            for(let rid of Object.keys(user.core.fileMap.HeroList)) {
                cur += parseFloat(user.core.fileMap.HeroList[rid].rate); //从角色表中获取掉率并进行累计, 注意这里的 HeroList 属于硬编码
                if(rate < cur) { //本次随机数小于累计概率，找到符合条件的碎片
                    bonus.id = (parseInt(rid) + 1).toString(); 
                    break;
                }
            }
        } 

        //添加资源
        user.getPocket().AddRes(bonus.num, false, bonus.type, bonus.id); //可以超过上限
    });
}
```

## 钱包

# 第三方H5游戏接入流程

## 备案

CP 通过CRM系统向主网备案，也可以通过命令字直接注册

```bash
cp.creaet cpName cpUrl
```

## 认证

1. 钱包到游戏的跳转

```js
let packet = {
    "data": {
        "cid": "c001",
        "uid": "p001",
        "time": 5224989,
        "addr": "",
        "pubkey": ""
    },
    "sig": ""
};
window.location.href = `url/?data=${JSON.stringify(packet.data)}&sig=${packet.sig}`;
```

2. 游戏到钱包的跳转

```js
window.location.href = `http://chick.gamegold.xin/?openid=${openid}&openkey=${openkey}`;
window.location.href = `http://h5.gamegold.xin/?openid=${openid}&openkey=${openkey}&token=${token}`;

//构造数据对象：
//1、填写信息
let src = {
    pid:'hello world',
    time: true,
};
//2、生成密钥管理对象
let key = KeyRing.generate();
key.witness = true; //设为隔离见证类型，这是因为 verifyData 中默认校验 bench32 类型的地址
//3、对数据对象进行签名，返回签名对象：打包了数据对象、公钥和签名
let signedData = key.signToken(src); //签署数据，同时也附加了公钥和地址
//4、序列化签名对象，广播
let pack = JSON.stringify(signedData);

//接收方（中继节点）流程：
//1、收到广播，反序列化报文为对象
let dst = JSON.parse(pack);
//3、利用对象中包含的公钥、签名，对产品信息进行签名校验
assert.strictEqual(true, utils.verifyData(dst));
//4、打印或使用经过校验的产品信息
console.log(dst.data);
```
